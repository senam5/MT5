//+------------------------------------------------------------------+
//| Structure Breakout with Fibonacci Zone Entries (M15)            |
//+------------------------------------------------------------------+
#property strict
#include <Trade/Trade.mqh>
CTrade trade;

//── USER INPUTS ─────────────────────────────────────────────────────
input double     LotSize             = 0.01;
input int        StructureLookback   = 10;
input double     ATR_SL_Multiplier   = 1.2;
input double     ATR_TP_Multiplier   = 2.0;
input int        GMTOffset           = -4;
input int        TradingStartHour    = 7;
input int        TradingEndHour      = 19;
input ENUM_TIMEFRAMES ATR_TF        = PERIOD_M15;
input double     MinEntryDistance    = 30.0; // in points
input bool       UseNewsFilter       = true;
input int        NewsMinutesBefore   = 60;
input int        NewsMinutesAfter    = 60;

//── FIB ZONE CONSTANTS ─────────────────────────────────────────────
#define FIB_MIN 0.5
#define FIB_MAX 0.618

//── INTERNAL STATE ─────────────────────────────────────────────────
datetime lastProcessed = 0;
double fibLow, fibHigh, fib50, fib618;
int breakoutDirection = 0; // 1 = buy, -1 = sell
bool fibZoneActive = false;
string breakoutLineName = "";

int macdHandle;
double macdBuffer[2], signalBuffer[2];
double lastEntryPrice = 0.0;

//+------------------------------------------------------------------+
bool IsNewsTime() {
   if (!UseNewsFilter) return false;

   MqlDateTime dt;
   TimeToStruct(TimeCurrent(), dt);

   // Simulated high-impact news (e.g., NFP - first Friday of the month at 08:30)
   if (dt.day_of_week == 5 && dt.day <= 7 && dt.hour == 8 && dt.min < 30) {
      return true; // Block trades during typical NFP release window
   }

   return false;
}

//+------------------------------------------------------------------+
int OnInit() {
   Print("Fibonacci Breakout Bot Initialized");
   macdHandle = iMACD(_Symbol, PERIOD_M15, 80, 160, 9, PRICE_CLOSE);
   if (macdHandle == INVALID_HANDLE) {
      Print("Failed to create MACD handle");
      return INIT_FAILED;
   }
   return INIT_SUCCEEDED;
}

//+------------------------------------------------------------------+
void OnTick() {
   // Total floating loss kill switch
   double totalLoss = 0.0;
   for (int i = PositionsTotal() - 1; i >= 0; i--) {
      if (PositionGetTicket(i) > 0 && PositionGetDouble(POSITION_PROFIT) < 0)
         totalLoss += PositionGetDouble(POSITION_PROFIT);
   }
   if (totalLoss <= -75 * _Point) {
      for (int i = PositionsTotal() - 1; i >= 0; i--) {
         if (PositionGetTicket(i) > 0)
            trade.PositionClose(PositionGetString(POSITION_SYMBOL));
      }
      Print("[SL-KillSwitch] Closed all trades due to total loss >= -75 points");
      return;
   }
   // Limit total open trades to 3
   if (PositionsTotal() >= 3) return;
   if (IsNewsTime()) return;

   datetime localTime = TimeCurrent() + (GMTOffset * 3600);
   MqlDateTime dt;
   TimeToStruct(localTime, dt);
   int hour = dt.hour;
   if (hour < TradingStartHour || hour >= TradingEndHour) return;

   datetime currentBar = iTime(_Symbol, PERIOD_M15, 0);
   if (currentBar == lastProcessed) return;
   lastProcessed = currentBar;

   // ── Check for new breakout ──
   double swingHigh = iHigh(_Symbol, PERIOD_M15, iHighest(_Symbol, PERIOD_M15, MODE_HIGH, StructureLookback, 2));
   double swingLow  = iLow(_Symbol, PERIOD_M15, iLowest(_Symbol, PERIOD_M15, MODE_LOW, StructureLookback, 2));

   double open  = iOpen(_Symbol, PERIOD_M15, 1);
   double close = iClose(_Symbol, PERIOD_M15, 1);

   if (close > swingHigh) {
      fibLow = open;
      fibHigh = close;
      breakoutDirection = 1;
      SetFibZone(fibLow, fibHigh);
   }
   else if (close < swingLow) {
      fibHigh = open;
      fibLow = close;
      breakoutDirection = -1;
      SetFibZone(fibHigh, fibLow);
   }

   // ── Check Fib Zone entry ──
   if (fibZoneActive) {
      double low = iLow(_Symbol, PERIOD_M15, 1);
      double high = iHigh(_Symbol, PERIOD_M15, 1);
      double atr[];
      int atrHandle = iATR(_Symbol, ATR_TF, 14);
      if (atrHandle == INVALID_HANDLE) return;
      if (CopyBuffer(atrHandle, 0, 1, 1, atr) <= 0) return;
      double atrVal = atr[0];

      if (CopyBuffer(macdHandle, 0, 1, 2, macdBuffer) <= 0) return;
      if (CopyBuffer(macdHandle, 1, 1, 2, signalBuffer) <= 0) return;

      bool macdBullish = macdBuffer[0] > signalBuffer[0];
      bool macdBearish = macdBuffer[0] < signalBuffer[0];

      double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
      double distance = MathAbs(currentPrice - lastEntryPrice) / _Point;

      if (breakoutDirection == 1 && low <= fib618 && high >= fib50 && macdBullish && (lastEntryPrice == 0.0 || distance >= MinEntryDistance)) {
         double sl = fibLow - ATR_SL_Multiplier * atrVal;
         double tp = fibHigh + ATR_TP_Multiplier * atrVal;
         if (trade.Buy(LotSize, _Symbol, fib50, sl, tp)) {
            if (breakoutLineName != "") ObjectDelete(0, breakoutLineName);
            lastEntryPrice = currentPrice;
         }
      }
      else if (breakoutDirection == -1 && high >= fib618 && low <= fib50 && macdBearish && (lastEntryPrice == 0.0 || distance >= MinEntryDistance)) {
         double sl = fibHigh + ATR_SL_Multiplier * atrVal;
         double tp = fibLow - ATR_TP_Multiplier * atrVal;
         currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
         if (trade.Sell(LotSize, _Symbol, fib50, sl, tp)) {
            if (breakoutLineName != "") ObjectDelete(0, breakoutLineName);
            lastEntryPrice = currentPrice;
         }
      }
   }
}

//+------------------------------------------------------------------+
void SetFibZone(double low, double high) {
   fib50 = low + FIB_MIN * (high - low);
   fib618 = low + FIB_MAX * (high - low);
   fibZoneActive = true;
}

//+------------------------------------------------------------------+
